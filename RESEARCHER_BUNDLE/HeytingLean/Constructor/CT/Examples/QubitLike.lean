import HeytingLean.Constructor.CT.InformationSound

/-!
# Qubit-like superinformation medium

A minimal concrete example: two “information observables” over `Bool × Bool` where
each observable is clonable, but their union is not.

This models the essential structure of a qubit without importing quantum mechanics:
* `X` (“computational basis”)  = `{(false,false), (true,true)}`
* `Y` (“diagonal basis”)       = `{(false,true), (true,false)}`
* `X ∪ Y` cannot be cloned (encoded as impossibility of a designated `copyXY` task)

The point of the example is *non-triviality*: we exhibit a `TaskCT` in which `copyTask` is
possible for `X` and `Y`, but `copyXY` is impossible for the combined variable.
-/

namespace HeytingLean
namespace Constructor
namespace CT
namespace Examples

open Set

/-- The substrate for the qubit-like example. -/
abbrev QubitLikeState : Type := Bool × Bool

/-- “Computational basis” attributes. -/
def compBasis : Set QubitLikeState :=
  {s | s = (false, false) ∨ s = (true, true)}

/-- “Diagonal basis” attributes. -/
def diagBasis : Set QubitLikeState :=
  {s | s = (false, true) ∨ s = (true, false)}

lemma mem_compBasis_ff : (false, false) ∈ compBasis := by
  left; rfl

lemma mem_compBasis_tt : (true, true) ∈ compBasis := by
  right; rfl

lemma mem_diagBasis_ft : (false, true) ∈ diagBasis := by
  left; rfl

lemma mem_diagBasis_tf : (true, false) ∈ diagBasis := by
  right; rfl

lemma mem_unionBasis_ft : (false, true) ∈ (compBasis ∪ diagBasis) := by
  right
  exact mem_diagBasis_ft

lemma not_mem_compBasis_ft : (false, true) ∉ compBasis := by
  intro h
  rcases h with h | h <;> cases h

lemma unionBasis_ne_compBasis : (compBasis ∪ diagBasis) ≠ compBasis := by
  intro hEq
  have : (false, true) ∈ compBasis := by
    simpa [hEq] using mem_unionBasis_ft
  exact not_mem_compBasis_ft this

lemma not_mem_diagBasis_ff : (false, false) ∉ diagBasis := by
  intro h
  rcases h with h | h <;> cases h

lemma mem_unionBasis_ff : (false, false) ∈ (compBasis ∪ diagBasis) := by
  left
  exact mem_compBasis_ff

lemma unionBasis_ne_diagBasis : (compBasis ∪ diagBasis) ≠ diagBasis := by
  intro hEq
  have : (false, false) ∈ diagBasis := by
    simpa [hEq] using mem_unionBasis_ff
  exact not_mem_diagBasis_ff this

/-!
## A non-trivial task model `TaskCT`

We implement only tasks built from two base copy tasks (for `compBasis` and `diagBasis`)
using serial/parallel composition. The “union copy” task is *not* in this generated class.
-/

/-- Base task: a “copy” operation for `compBasis` (purely schematic). -/
def copyComp : Task QubitLikeState :=
  { arcs := [(compBasis, compBasis)] }

/-- Base task: a “copy” operation for `diagBasis` (purely schematic). -/
def copyDiag : Task QubitLikeState :=
  { arcs := [(diagBasis, diagBasis)] }

/-- A designated “copy the union” task. This is *not* generated by the allowed constructors. -/
def copyUnion : Task QubitLikeState :=
  { arcs := [(compBasis ∪ diagBasis, compBasis ∪ diagBasis)] }

private def AllowedArc : (Set QubitLikeState × Set QubitLikeState) → Prop
  | a => a = (compBasis, compBasis) ∨ a = (diagBasis, diagBasis)

private lemma copyUnion_arc_not_allowed : ¬ AllowedArc (compBasis ∪ diagBasis, compBasis ∪ diagBasis) := by
  intro h
  rcases h with h | h
  · -- would force union basis = compBasis
    have h1 : (compBasis ∪ diagBasis) = compBasis := by
      simpa using congrArg Prod.fst h
    exact unionBasis_ne_compBasis h1
  · -- would force union basis = diagBasis
    have h1 : (compBasis ∪ diagBasis) = diagBasis := by
      simpa using congrArg Prod.fst h
    exact unionBasis_ne_diagBasis h1

/-- Constructors for the qubit-like task model: just two primitive constructors and
closure under serial/parallel composition. -/
inductive QubitCtor
  | comp
  | diag
  | seq (c₁ c₂ : QubitCtor)
  | par (c₁ c₂ : QubitCtor)

/-- Which tasks are implemented by which constructors. -/
inductive Implements : QubitCtor → Task QubitLikeState → Prop
  | comp : Implements QubitCtor.comp copyComp
  | diag : Implements QubitCtor.diag copyDiag
  | seq {c₁ c₂ : QubitCtor} {T U : Task QubitLikeState} :
      Implements c₁ T → Implements c₂ U → Implements (QubitCtor.seq c₁ c₂) (Task.seq T U)
  | par {c₁ c₂ : QubitCtor} {T U : Task QubitLikeState} :
      Implements c₁ T → Implements c₂ U → Implements (QubitCtor.par c₁ c₂) (Task.par T U)

private lemma implements_allowed_arcs {c : QubitCtor} {T : Task QubitLikeState} :
    Implements c T → ∀ a, a ∈ T.arcs → AllowedArc a := by
  intro hImpl
  induction hImpl with
  | comp =>
      intro a ha
      simp [copyComp, AllowedArc] at ha ⊢
      exact Or.inl ha
  | diag =>
      intro a ha
      simp [copyDiag, AllowedArc] at ha ⊢
      exact Or.inr ha
  | seq hT hU ihT ihU =>
      intro a ha
      simp [Task.seq, List.mem_append] at ha
      rcases ha with ha | ha
      · exact ihT a ha
      · exact ihU a ha
  | par hT hU ihT ihU =>
      intro a ha
      simp [Task.par, List.mem_append] at ha
      rcases ha with ha | ha
      · exact ihT a ha
      · exact ihU a ha

private lemma not_implements_copyUnion (c : QubitCtor) : ¬ Implements c copyUnion := by
  intro h
  have hAllowed :
      AllowedArc (compBasis ∪ diagBasis, compBasis ∪ diagBasis) :=
    implements_allowed_arcs h (compBasis ∪ diagBasis, compBasis ∪ diagBasis) (by
      simp [copyUnion])
  exact copyUnion_arc_not_allowed hAllowed

/-- The `TaskCT` instance for the qubit-like example. -/
def qubitLikeTaskCT : TaskCT QubitLikeState where
  Ctor := QubitCtor
  implements := Implements
  seqCtor := QubitCtor.seq
  parCtor := QubitCtor.par
  implements_seq := by
    intro c₁ c₂ T U hT hU
    exact Implements.seq hT hU
  implements_par := by
    intro c₁ c₂ T U hT hU
    exact Implements.par hT hU

/-!
## Information variables and the superinformation witness

We keep permutation tasks trivial (one code, identity task); copying is witnessed by the two
primitive constructors. The superinformation axiom is the impossibility of `copyUnion`.
-/

private def compVar : Variable QubitLikeState where
  attrs := [compBasis]
  pairwiseDisjoint := by
    intro i j hi hj hij
    have hi0 : i = 0 := by
      have : i < 1 := by simpa using hi
      exact Nat.lt_one_iff.mp this
    have hj0 : j = 0 := by
      have : j < 1 := by simpa using hj
      exact Nat.lt_one_iff.mp this
    exact (hij (by simp [hi0, hj0])).elim

private def diagVar : Variable QubitLikeState where
  attrs := [diagBasis]
  pairwiseDisjoint := by
    intro i j hi hj hij
    have hi0 : i = 0 := by
      have : i < 1 := by simpa using hi
      exact Nat.lt_one_iff.mp this
    have hj0 : j = 0 := by
      have : j < 1 := by simpa using hj
      exact Nat.lt_one_iff.mp this
    exact (hij (by simp [hi0, hj0])).elim

private def compInfo : TaskCT.InfoVariable QubitLikeState qubitLikeTaskCT where
  toVariable := compVar
  Perm := Unit
  permTask := fun _ => copyComp
  perm_possible := by
    intro _
    refine ⟨QubitCtor.comp, ?_⟩
    exact Implements.comp
  copyTask := copyComp
  copy_possible := by
    refine ⟨QubitCtor.comp, ?_⟩
    exact Implements.comp

private def diagInfo : TaskCT.InfoVariable QubitLikeState qubitLikeTaskCT where
  toVariable := diagVar
  Perm := Unit
  permTask := fun _ => copyDiag
  perm_possible := by
    intro _
    refine ⟨QubitCtor.diag, ?_⟩
    exact Implements.diag
  copyTask := copyDiag
  copy_possible := by
    refine ⟨QubitCtor.diag, ?_⟩
    exact Implements.diag

-- NOTE: the “permutation task” is intentionally schematic; for a richer model we would give
-- actual permutation tasks and show their possibility. Here we only need non-trivial cloning behaviour.

/-- Concrete superinformation medium: `X` and `Y` are clonable but the union-copy task is impossible. -/
def qubitLikeSuperinfo : TaskCT.SuperinformationMedium QubitLikeState qubitLikeTaskCT where
  X := compInfo
  Y := diagInfo
  XY := { attrs := [compBasis ∪ diagBasis]
          pairwiseDisjoint := by
            intro i j hi hj hij
            have hi0 : i = 0 := by
              have : i < 1 := by simpa using hi
              exact Nat.lt_one_iff.mp this
            have hj0 : j = 0 := by
              have : j < 1 := by simpa using hj
              exact Nat.lt_one_iff.mp this
            exact (hij (by simp [hi0, hj0])).elim }
  copyXY := copyUnion
  no_copyXY := by
    intro hPossible
    rcases hPossible with ⟨c, hc⟩
    exact not_implements_copyUnion c hc

end Examples
end CT
end Constructor
end HeytingLean
